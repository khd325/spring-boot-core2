# 동적 프록시 기술

로그 추적기라는 부가 기능을 적용할 대상 클래스 수만큼 프록시 클래스를 만들어야하는 단점을 JKD 동적 프록시 기술이나 CGLIB 오픈소스 기술을 활용하면 프록시 객체를 동적으로 만들어낼 수 있다.

JDK 동적 프록시를 이해하기 위해서는 자바의 리플렉션 기술을 이해해야 한다.

---

## 리플렉션

```java

@Slf4j
public class ReflectionTest {

    @Test
    public void reflection0() {
        Hello target = new Hello();

        //공통 로직1 시작
        log.info("start");
        String result1 = target.callA();
        log.info("result={}", result1);

        //공통 로직2 시작
        log.info("start");
        String result2 = target.callB();
        log.info("result={}", result2);

    }
}
```

`reflection0()`는 호출하는 메서드만 다르고 흐름은 완전히 같다.

`callA()`와 `callB()`를 동적으로 처리가 가능하면 공통화가 가능할 것이다.

이럴 때 리플렉션을 사용할 수 있다.

```java

@Slf4j
public class ReflectionTest {

    @Test
    public void reflection1() throws Exception {
        Class classHello = Class.forName("hello.proxy.jdkdynamic.ReflectionTest$Hello");

        Hello target = new Hello();

        Method methodCallA = classHello.getMethod("callA");
        Object result1 = methodCallA.invoke(target);
        log.info("result1={}", result1);

        Method methodCallB = classHello.getMethod("callB");
        Object result2 = methodCallB.invoke(target);
        log.info("result2={}", result2);

    }
}
```

`Class.forName`: 클래스 메타정보 획득

`classHello.getMethod("callA")`: 해당 클래스의 메서드 메타정보 획득

`methodCallA.invoke(target)`: 획득한 메서드의 메타정보로 실제 인스턴스 메서드 호출

methodCallA는 Hello 클래스의 callA() 메서드 메타정보이다.

이제 동적으로 변경되는 공통 로직을 만들 수 있다.

```java

@Slf4j
public class ReflectionTest {

    @Test
    public void reflection2() throws Exception {
        Class classHello = Class.forName("hello.proxy.jdkdynamic.ReflectionTest$Hello");

        Hello target = new Hello();

        Method methodCallA = classHello.getMethod("callA");
        dynamicCall(methodCallA, target);

        Method methodCallB = classHello.getMethod("callB");
        dynamicCall(methodCallB, target);

    }

    private void dynamicCall(Method method, Object target) throws Exception {
        log.info("start");
        Object result = method.invoke(target);
        log.info("result={}", result);

    }
}
```

dynamicCall의 파라미터로 메서드의 메타정보와 실행할 인스턴스를 넘겨주면 동적으로 공통로직을 처리할 수 있다.

**주의**

리플렉션 기술은 런타임에 동작하기 때문에 컴파일 시점에 오류를 잡을 수 없다.

getMethod()로 메서드의 메타정보를 획득할 때 실수로 "callA"가 아닌 "callAS"라고 적어도 컴파일 오류가 발생하지 않기 때문에 즉시 확인할 수 없게된다.

---

## JKD 동적 프록시

프록시 객체를 동적으로 런타임 시점에 대신 만들어주고 원하는 실행 로직을 지정할 수 있다.

> JKD 동적 프록시는 인터페이스를 기반으로 프록시를 동적으로 만들어주기 때문에 인터페이스가 필수

```java
public interface AInterface {

    String call();
}

@Slf4j
public class AImpl implements AInterface {

    @Override
    public String call() {
        log.info("A 호출");
        return "a";
    }
}
```

JDK 동적 프록시를 적용할 로직은 `InvocationHandler` 인터페이스를 구현해서 작성한다.

```java

@Slf4j
public class TimeInvocationHandler implements InvocationHandler {

    private final Object target;

    public TimeInvocationHandler(Object target) {
        this.target = target;
    }

    /**
     * 프록시 적용 로직 구현
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        log.info("TimeProxy 실행");
        long startTime = System.currentTimeMillis();

        Object result = method.invoke(target, args);

        long endTime = System.currentTimeMillis();

        long resultTime = endTime - startTime;
        log.info("TimeProxy 종료 resultTime={}", resultTime);
        return result;
    }
}
```

- proxy: 프록시 자신
- method: 프록시가 호출할 대상 메서드
- args: 메서드 호출시 전달한 인수

`method.invoke(target,args)`: 리플렉션을 사용해서 `target` 인스턴스의 메서드를 실행한다.

```java

@Slf4j
public class JdkDynamicProxyTest {

    @Test
    public void dynamicA() {
        AInterface target = new AImpl();

        TimeInvocationHandler handler = new TimeInvocationHandler(target);

        AInterface proxy = (AInterface) Proxy.newProxyInstance(AInterface.class.getClassLoader(), new Class[]{AInterface.class}, handler);
        proxy.call();
        log.info("targetClass={}", target.getClass());
        log.info("proxyClass={}", proxy.getClass());
    }
}
```

`new TimeInvocationHandler(target)`: 동적 프록시를 적용할 핸들러

`Proxy.newProxyInstance(AInterface.class.getClassLoader(), new Class[]{AInterface.class}, handler)`: 핸들러 파라미터를 바탕으로 동적
프록시를 생성해서 프록시를 반환함

`proxy.call()`: 프록시의 메서드를 호출하면 `TimeInvocationHandler`에 구현한 `invoke`가 실행되고 파라미터인  `method`와 `args`에 어떤 메서드를 호출하고 어떤 인수를 넘기는지 알려준다.

```java

@Slf4j
public class TimeInvocationHandler implements InvocationHandler {

    private final Object target;

    public TimeInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //...
        Object result = method.invoke(target, args); //target의 call
        //...
    }
}

```

`method.invoke(target,args)`: target으로 넣어놓은 AImpl의 call이 실행됨

