# 프록시 패턴과 데코레이터 패턴

**직접 호출**

클라이언트와 서버 개념에서 클라이언트가 서버를 직접 호출하고 처리 결과를 직접 받는 것

`Client` -> `Server`


**간접 호출**

클라이언트가 요청항 결과를 서버에 직접 요청하는 것이 아니라 대리자를 통해서 간접적으로 서버에 요청하는 것

`Client` -> `Proxy` -> `Server`

> 객체에서 프록시가 되려면 클라이언트는 서버에 요청을 한 것인지, 프록시에게 요청을 한 것인지 몰라야 한다.
> 
> **서버와 프록시는 같은 인터페이스를 사용해야 함**


### 프록시의 주요 기능

- 접근 제어 (프록시 패턴)
  - 권한에 따른 접근 차단
  - 캐싱
  - 지연 로딩
- 부가 기능 (데코레이터 패턴)
  - 서버가 제공하는 기능에 더해서 부가 기능을 수행
  - ex) 요청 값, 응답 값을 중간에 변형
  - 실행 시간을 측정하거나 로그 남기기

---

## 프록시 패턴 - 예제1

```java
public interface Subject {
    String operation();
}

public class RealSubject implements Subject{
    @Override
    public String operation() {
        log.info("실제 객체 호출");
        sleep(1000);
        return "data";
    }

    private void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class ProxyPatternClient {

    private Subject subject;

    public ProxyPatternClient(Subject subject) {
        this.subject = subject;
    }

    public void execute() {
        subject.operation();
    }
}
```

`ProxyPatternClient`는 `Subject` 인터페이스에 의존하고,`Subject`를 호출하는 클라이언트 코드

```java
public class ProxyPatternTest {

    @Test
    public void noProxyTest() {
        RealSubject realSubject = new RealSubject();
        ProxyPatternClient client = new ProxyPatternClient(realSubject);
        client.execute();
        client.execute();
        client.execute();
    }
}
```

테스트를 실행시키면 총 3초의 시간이 걸리게 된다.

만약 데이터가 변하지 않는다면 어딘가에 보관해두고 이미 조회한 데이터를 사용하는 것이 좋다. (**캐시**)

---

## 프록시 패턴 - 예제2

```java
public class CacheProxy implements Subject{

    private Subject target;
    private String cacheValue;

    public CacheProxy(Subject target) {
        this.target = target;
    }

    @Override
    public String operation() {
        log.info("프록시 호출");

        if(cacheValue == null) {
            cacheValue = target.operation();
        }
        return cacheValue;
    }
}
```

프록시도 실제 객체와 그 모양이 같기 때문에 `Subject` 인터페이스를 구현한다.

`target`: 실제 객체의 참조. 프록시가 호출하는 대상

`operation`: cacheValue에 값을 저장하고 값이 있으면 target을 호출하지 않는다.

```java
public class ProxyPatternTest {
    /**
     * client -> cacheProxy -> realSubject
     */
    @Test
    public void cacheProxyTest() {
        RealSubject realSubject = new RealSubject();
        CacheProxy cacheProxy = new CacheProxy(realSubject);
        ProxyPatternClient client = new ProxyPatternClient(cacheProxy);

        client.execute();
        client.execute();
        client.execute();
    }
}
```

`client`에 `realSubject`가 아닌 `cacheProxy`를 주입하면 `client -> cacheProxy -> realSubject` 와 같은 의존관계가 완성된다.

프록시 패턴의 핵심은 `RealSubject` 코드와 클라이언트 코드를 변경하지 않고, 프록시를 도입해서 접근 제어를 할 수 있다는 것이다.

클라이언트의 코드를 변경하지 않고 자유롭게 프록시를 넣고 뺄 수 있기 때문에 실제 클라이언트 입장에서는 프록시 객체가 주입되었는지, 실제 객체가 주입되었는지 모른다.

